// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Package serverless provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package serverless

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyScopes = "apiKey.Scopes"
)

// Defines values for CSP.
const (
	Aws   CSP = "aws"
	Azure CSP = "azure"
	Gcp   CSP = "gcp"
)

// Defines values for ElasticsearchOptimizedFor.
const (
	GeneralPurpose ElasticsearchOptimizedFor = "general_purpose"
	Vector         ElasticsearchOptimizedFor = "vector"
)

// Defines values for ElasticsearchProjectType.
const (
	ElasticsearchProjectTypeElasticsearch ElasticsearchProjectType = "elasticsearch"
)

// Defines values for ElasticsearchProjectCreatedType.
const (
	ElasticsearchProjectCreatedTypeElasticsearch ElasticsearchProjectCreatedType = "elasticsearch"
)

// Defines values for ObservabilityProjectType.
const (
	ObservabilityProjectTypeObservability ObservabilityProjectType = "observability"
)

// Defines values for ObservabilityProjectCreatedType.
const (
	ObservabilityProjectCreatedTypeObservability ObservabilityProjectCreatedType = "observability"
)

// Defines values for OptionalSecurityAdminFeaturesPackage.
const (
	OptionalSecurityAdminFeaturesPackageEnterprise OptionalSecurityAdminFeaturesPackage = "enterprise"
	OptionalSecurityAdminFeaturesPackageStandard   OptionalSecurityAdminFeaturesPackage = "standard"
)

// Defines values for ProjectStatusPhase.
const (
	Initialized  ProjectStatusPhase = "initialized"
	Initializing ProjectStatusPhase = "initializing"
)

// Defines values for SecurityAdminFeaturesPackage.
const (
	SecurityAdminFeaturesPackageEnterprise SecurityAdminFeaturesPackage = "enterprise"
	SecurityAdminFeaturesPackageStandard   SecurityAdminFeaturesPackage = "standard"
)

// Defines values for SecurityProductLine.
const (
	SecurityProductLineCloud    SecurityProductLine = "cloud"
	SecurityProductLineEndpoint SecurityProductLine = "endpoint"
	SecurityProductLineSecurity SecurityProductLine = "security"
)

// Defines values for SecurityProductTier.
const (
	Complete   SecurityProductTier = "complete"
	Essentials SecurityProductTier = "essentials"
)

// Defines values for SecurityProjectType.
const (
	SecurityProjectTypeSecurity SecurityProjectType = "security"
)

// Defines values for SecurityProjectCreatedType.
const (
	Security SecurityProjectCreatedType = "security"
)

// CSP The identifier of the cloud service provider hosting this region.
type CSP string

// CloudID The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
type CloudID = string

// CreateElasticsearchProjectRequest A request to create an Elasticsearch serverless project.
type CreateElasticsearchProjectRequest struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// OptimizedFor The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.
	OptimizedFor *ElasticsearchOptimizedFor `json:"optimized_for,omitempty"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// SearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch.
	SearchLake *ElasticsearchSearchLake `json:"search_lake,omitempty"`
}

// CreateObservabilityProjectRequest A request to create an Observability project.
type CreateObservabilityProjectRequest struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`
}

// CreateSecurityProjectRequest A request to create a Security project.
type CreateSecurityProjectRequest struct {
	// AdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR)
	AdminFeaturesPackage *SecurityAdminFeaturesPackage `json:"admin_features_package,omitempty"`

	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name         ProjectName            `json:"name"`
	ProductTypes *[]SecurityProductType `json:"product_types,omitempty"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`
}

// ElasticsearchOptimizedFor The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.
type ElasticsearchOptimizedFor string

// ElasticsearchProject An Elasticsearch serverless project.
type ElasticsearchProject struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints ElasticsearchProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// OptimizedFor The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.
	OptimizedFor ElasticsearchOptimizedFor `json:"optimized_for"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// SearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch.
	SearchLake *ElasticsearchSearchLake `json:"search_lake,omitempty"`

	// Type the type of the project
	Type ElasticsearchProjectType `json:"type"`
}

// ElasticsearchProjectType the type of the project
type ElasticsearchProjectType string

// ElasticsearchProjectCreated The created Elasticsearch project along with credentials to access Elasticsearch.
type ElasticsearchProjectCreated struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Credentials Basic auth credentials to access the Elasticsearch API.
	Credentials ProjectCredentials `json:"credentials"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints ElasticsearchProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// OptimizedFor The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.
	OptimizedFor ElasticsearchOptimizedFor `json:"optimized_for"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// SearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch.
	SearchLake *ElasticsearchSearchLake `json:"search_lake,omitempty"`

	// Type the type of the project
	Type ElasticsearchProjectCreatedType `json:"type"`
}

// ElasticsearchProjectCreatedType the type of the project
type ElasticsearchProjectCreatedType string

// ElasticsearchProjectEndpoints The endpoints to access the different apps of the project.
type ElasticsearchProjectEndpoints struct {
	// Elasticsearch The endpoint to access elasticsearch.
	Elasticsearch string `json:"elasticsearch"`

	// Kibana The endpoint to access kibana.
	Kibana string `json:"kibana"`
}

// ElasticsearchProjectList A paginated list of serverless elasticsearch projects.
type ElasticsearchProjectList struct {
	// Items The actual projects.
	Items []ElasticsearchProject `json:"items"`

	// NextPage A token to fetch the next page.
	NextPage *string `json:"next_page,omitempty"`
}

// ElasticsearchSearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch.
type ElasticsearchSearchLake struct {
	// BoostWindow Determines how much data can benefit from faster search. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. The system dynamically adjusts the cache allocated to your project based on how much data you ingest during the period defined by your Search Boost Window.
	BoostWindow *int `json:"boost_window,omitempty"`

	// SearchPower Controls how fast searches are against your project data. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. You can either increase the performance of searches on cached data by adding replicas, or reduce the quantity of cached data by a static factor to save on costs.
	SearchPower *int `json:"search_power,omitempty"`
}

// ErrorResponse An error response returned by the API.
type ErrorResponse struct {
	// Code An identifier for this type of error.
	Code string `json:"code"`

	// Message A human-readable message of the error.
	Message string `json:"message"`
}

// MultiErrorResponse A non-empty list of errors.
type MultiErrorResponse struct {
	Errors []ErrorResponse `json:"errors"`
}

// ObservabilityProject An Observability project.
type ObservabilityProject struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints ObservabilityProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// Type the type of the project
	Type ObservabilityProjectType `json:"type"`
}

// ObservabilityProjectType the type of the project
type ObservabilityProjectType string

// ObservabilityProjectCreated The created Observability project along with credentials to access Elasticsearch.
type ObservabilityProjectCreated struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Credentials Basic auth credentials to access the Elasticsearch API.
	Credentials ProjectCredentials `json:"credentials"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints ObservabilityProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name ProjectName `json:"name"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// Type the type of the project
	Type ObservabilityProjectCreatedType `json:"type"`
}

// ObservabilityProjectCreatedType the type of the project
type ObservabilityProjectCreatedType string

// ObservabilityProjectEndpoints The endpoints to access the different apps of the project.
type ObservabilityProjectEndpoints struct {
	// Apm The endpoint to access apm.
	Apm string `json:"apm"`

	// Elasticsearch The endpoint to access elasticsearch.
	Elasticsearch string `json:"elasticsearch"`

	// Kibana The endpoint to access kibana.
	Kibana string `json:"kibana"`
}

// ObservabilityProjectList A paginated list of serverless Observability projects.
type ObservabilityProjectList struct {
	// Items The actual projects.
	Items []ObservabilityProject `json:"items"`

	// NextPage A token to fetch the next page.
	NextPage *string `json:"next_page,omitempty"`
}

// OptionalElasticsearchSearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch. It can be passed as `null` to reset configuration to the default values.
type OptionalElasticsearchSearchLake struct {
	// BoostWindow Determines how much data can benefit from faster search. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. The system dynamically adjusts the cache allocated to your project based on how much data you ingest during the period defined by your Search Boost Window. It can be passed as `null` to reset the Search Boost Window to the default value.
	BoostWindow *int `json:"boost_window"`

	// SearchPower Controls how fast searches are against your project data. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. You can either increase the performance of searches on cached data by adding replicas, or reduce the quantity of cached data by a static factor to save on costs. It can be passed as `null` to reset the Search Power to the default value.
	SearchPower *int `json:"search_power"`
}

// OptionalSecurityAdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR). It can be passed as `null` to reset the admin features package to the default value.
type OptionalSecurityAdminFeaturesPackage string

// PatchElasticsearchProjectRequest A request to patch an existing Elasticsearch serverless project.
type PatchElasticsearchProjectRequest struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name *ProjectName `json:"name,omitempty"`

	// SearchLake Configuration for entire set of capabilities that make the data searchable in Elasticsearch. It can be passed as `null` to reset configuration to the default values.
	SearchLake *OptionalElasticsearchSearchLake `json:"search_lake"`
}

// PatchObservabilityProjectRequest A request to update an existing Observability project.
type PatchObservabilityProjectRequest struct {
	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name *ProjectName `json:"name,omitempty"`
}

// PatchSecurityProjectRequest A request to patch an existing Security project.
type PatchSecurityProjectRequest struct {
	// AdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR). It can be passed as `null` to reset the admin features package to the default value.
	AdminFeaturesPackage *OptionalSecurityAdminFeaturesPackage `json:"admin_features_package"`

	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias *ProjectAlias `json:"alias,omitempty"`

	// Name Descriptive name for a project.
	Name         *ProjectName           `json:"name,omitempty"`
	ProductTypes *[]SecurityProductType `json:"product_types"`
}

// ProjectAlias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
type ProjectAlias = string

// ProjectCredentials Basic auth credentials to access the Elasticsearch API.
type ProjectCredentials struct {
	// Password Basic auth password that can be used to access the Elasticsearch API.
	Password string `json:"password"`

	// Username Basic auth username that can be used to access the Elasticsearch API.
	Username string `json:"username"`
}

// ProjectID ID of the project.
type ProjectID = string

// ProjectMetadata Additional details about the project.
type ProjectMetadata struct {
	// CreatedAt Date and time when the project was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy ID of the user.
	CreatedBy UserID `json:"created_by"`

	// OrganizationId The Organization ID who owns the project.
	OrganizationId string `json:"organization_id"`

	// SuspendedAt Date and time when the project was suspended.
	SuspendedAt *time.Time `json:"suspended_at,omitempty"`

	// SuspendedReason Reason why the project was suspended.
	SuspendedReason *string `json:"suspended_reason,omitempty"`
}

// ProjectName Descriptive name for a project.
type ProjectName = string

// ProjectRole A role name for a particular project
type ProjectRole = string

// ProjectRoleDescription A role description for a particular role
type ProjectRoleDescription = string

// ProjectRoleDetails Roles of a serverless project.
type ProjectRoleDetails struct {
	// Description A role description for a particular role
	Description ProjectRoleDescription `json:"description"`

	// Name A role name for a particular project
	Name ProjectRole `json:"name"`
}

// ProjectRoles defines model for ProjectRoles.
type ProjectRoles struct {
	Roles *[]ProjectRoleDetails `json:"roles,omitempty"`
}

// ProjectRolesByProjectID defines model for ProjectRolesByProjectID.
type ProjectRolesByProjectID map[string]ProjectRoles

// ProjectStatus Status of a serverless project.
type ProjectStatus struct {
	// Phase Current phase of the project:
	// - initializing: the project is still being created and is not ready for use yet
	// - initialized: the project has been created successfully and is ready for use
	Phase ProjectStatusPhase `json:"phase"`
}

// ProjectStatusPhase Current phase of the project:
// - initializing: the project is still being created and is not ready for use yet
// - initialized: the project has been created successfully and is ready for use
type ProjectStatusPhase string

// Region A Cloud Service Provider region.
type Region struct {
	// Csp The identifier of the cloud service provider hosting this region.
	Csp CSP `json:"csp"`

	// CspRegion The unique identifier of the underlying cloud service provider region.
	CspRegion string `json:"csp_region"`

	// Id Unique human-readable identifier for a region in Elastic Cloud.
	Id RegionID `json:"id"`

	// Name The human readable name for the region
	Name string `json:"name"`
}

// RegionID Unique human-readable identifier for a region in Elastic Cloud.
type RegionID = string

// SecurityAdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR)
type SecurityAdminFeaturesPackage string

// SecurityProductLine The identifier of the Security Solution product line.
type SecurityProductLine string

// SecurityProductTier The identifier of the Security Solution product tier.
type SecurityProductTier string

// SecurityProductType Defines Security product type object with product line and tier dimensions.
type SecurityProductType struct {
	// ProductLine The identifier of the Security Solution product line.
	ProductLine SecurityProductLine `json:"product_line"`

	// ProductTier The identifier of the Security Solution product tier.
	ProductTier SecurityProductTier `json:"product_tier"`
}

// SecurityProject A Security project.
type SecurityProject struct {
	// AdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR)
	AdminFeaturesPackage *SecurityAdminFeaturesPackage `json:"admin_features_package,omitempty"`

	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints SecurityProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name         ProjectName            `json:"name"`
	ProductTypes *[]SecurityProductType `json:"product_types,omitempty"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// Type the type of the project
	Type SecurityProjectType `json:"type"`
}

// SecurityProjectType the type of the project
type SecurityProjectType string

// SecurityProjectCreated The created Security project along with credentials to access Elasticsearch.
type SecurityProjectCreated struct {
	// AdminFeaturesPackage admin features package (BYOK, BYOIDP, CCS, CCR)
	AdminFeaturesPackage *SecurityAdminFeaturesPackage `json:"admin_features_package,omitempty"`

	// Alias A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.
	Alias ProjectAlias `json:"alias"`

	// CloudId The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.
	CloudId CloudID `json:"cloud_id"`

	// Credentials Basic auth credentials to access the Elasticsearch API.
	Credentials ProjectCredentials `json:"credentials"`

	// Endpoints The endpoints to access the different apps of the project.
	Endpoints SecurityProjectEndpoints `json:"endpoints"`

	// Id ID of the project.
	Id ProjectID `json:"id"`

	// Metadata Additional details about the project.
	Metadata ProjectMetadata `json:"metadata"`

	// Name Descriptive name for a project.
	Name         ProjectName            `json:"name"`
	ProductTypes *[]SecurityProductType `json:"product_types,omitempty"`

	// RegionId Unique human-readable identifier for a region in Elastic Cloud.
	RegionId RegionID `json:"region_id"`

	// Type the type of the project
	Type SecurityProjectCreatedType `json:"type"`
}

// SecurityProjectCreatedType the type of the project
type SecurityProjectCreatedType string

// SecurityProjectEndpoints The endpoints to access the different apps of the project.
type SecurityProjectEndpoints struct {
	// Elasticsearch The endpoint to access elasticsearch.
	Elasticsearch string `json:"elasticsearch"`

	// Kibana The endpoint to access kibana.
	Kibana string `json:"kibana"`
}

// SecurityProjectList A paginated list of serverless Security projects.
type SecurityProjectList struct {
	// Items The actual projects.
	Items []SecurityProject `json:"items"`

	// NextPage A token to fetch the next page.
	NextPage *string `json:"next_page,omitempty"`
}

// UserID ID of the user.
type UserID = string

// BadRequest A non-empty list of errors.
type BadRequest = MultiErrorResponse

// NotFound A non-empty list of errors.
type NotFound = MultiErrorResponse

// Unauthorized A non-empty list of errors.
type Unauthorized = MultiErrorResponse

// UnprocessableEntity A non-empty list of errors.
type UnprocessableEntity = MultiErrorResponse

// ListElasticsearchProjectsParams defines parameters for ListElasticsearchProjects.
type ListElasticsearchProjectsParams struct {
	// PageSize Maximum number of projects returned in the response.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// NextPage Token to the next page containing the list of projects.
	NextPage *string `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// DeleteElasticsearchProjectParams defines parameters for DeleteElasticsearchProject.
type DeleteElasticsearchProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// PatchElasticsearchProjectParams defines parameters for PatchElasticsearchProject.
type PatchElasticsearchProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResetElasticsearchProjectCredentialsParams defines parameters for ResetElasticsearchProjectCredentials.
type ResetElasticsearchProjectCredentialsParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResumeElasticsearchProjectParams defines parameters for ResumeElasticsearchProject.
type ResumeElasticsearchProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates.
	IfMatch *string `json:"If-Match,omitempty"`
}

// ListObservabilityProjectsParams defines parameters for ListObservabilityProjects.
type ListObservabilityProjectsParams struct {
	// PageSize Maximum number of projects returned in the response.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// NextPage Token to the next page containing the list of projects.
	NextPage *string `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// DeleteObservabilityProjectParams defines parameters for DeleteObservabilityProject.
type DeleteObservabilityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// PatchObservabilityProjectParams defines parameters for PatchObservabilityProject.
type PatchObservabilityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResetObservabilityProjectCredentialsParams defines parameters for ResetObservabilityProjectCredentials.
type ResetObservabilityProjectCredentialsParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResumeObservabilityProjectParams defines parameters for ResumeObservabilityProject.
type ResumeObservabilityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates.
	IfMatch *string `json:"If-Match,omitempty"`
}

// ListSecurityProjectsParams defines parameters for ListSecurityProjects.
type ListSecurityProjectsParams struct {
	// PageSize Maximum number of projects returned in the response.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// NextPage Token to the next page containing the list of projects.
	NextPage *string `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// DeleteSecurityProjectParams defines parameters for DeleteSecurityProject.
type DeleteSecurityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// PatchSecurityProjectParams defines parameters for PatchSecurityProject.
type PatchSecurityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResetSecurityProjectCredentialsParams defines parameters for ResetSecurityProjectCredentials.
type ResetSecurityProjectCredentialsParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates
	IfMatch *string `json:"If-Match,omitempty"`
}

// ResumeSecurityProjectParams defines parameters for ResumeSecurityProject.
type ResumeSecurityProjectParams struct {
	// IfMatch ETag value fetched in a previous GET project request. Used to prevent simultaneous updates.
	IfMatch *string `json:"If-Match,omitempty"`
}

// CreateElasticsearchProjectJSONRequestBody defines body for CreateElasticsearchProject for application/json ContentType.
type CreateElasticsearchProjectJSONRequestBody = CreateElasticsearchProjectRequest

// PatchElasticsearchProjectJSONRequestBody defines body for PatchElasticsearchProject for application/json ContentType.
type PatchElasticsearchProjectJSONRequestBody = PatchElasticsearchProjectRequest

// CreateObservabilityProjectJSONRequestBody defines body for CreateObservabilityProject for application/json ContentType.
type CreateObservabilityProjectJSONRequestBody = CreateObservabilityProjectRequest

// PatchObservabilityProjectJSONRequestBody defines body for PatchObservabilityProject for application/json ContentType.
type PatchObservabilityProjectJSONRequestBody = PatchObservabilityProjectRequest

// CreateSecurityProjectJSONRequestBody defines body for CreateSecurityProject for application/json ContentType.
type CreateSecurityProjectJSONRequestBody = CreateSecurityProjectRequest

// PatchSecurityProjectJSONRequestBody defines body for PatchSecurityProject for application/json ContentType.
type PatchSecurityProjectJSONRequestBody = PatchSecurityProjectRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListElasticsearchProjects request
	ListElasticsearchProjects(ctx context.Context, params *ListElasticsearchProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateElasticsearchProjectWithBody request with any body
	CreateElasticsearchProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateElasticsearchProject(ctx context.Context, body CreateElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteElasticsearchProject request
	DeleteElasticsearchProject(ctx context.Context, id ProjectID, params *DeleteElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElasticsearchProject request
	GetElasticsearchProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchElasticsearchProjectWithBody request with any body
	PatchElasticsearchProjectWithBody(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchElasticsearchProject(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, body PatchElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetElasticsearchProjectCredentials request
	ResetElasticsearchProjectCredentials(ctx context.Context, id ProjectID, params *ResetElasticsearchProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeElasticsearchProject request
	ResumeElasticsearchProject(ctx context.Context, id ProjectID, params *ResumeElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElasticsearchProjectRoles request
	GetElasticsearchProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetElasticsearchProjectStatus request
	GetElasticsearchProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObservabilityProjects request
	ListObservabilityProjects(ctx context.Context, params *ListObservabilityProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateObservabilityProjectWithBody request with any body
	CreateObservabilityProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateObservabilityProject(ctx context.Context, body CreateObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObservabilityProject request
	DeleteObservabilityProject(ctx context.Context, id ProjectID, params *DeleteObservabilityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObservabilityProject request
	GetObservabilityProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchObservabilityProjectWithBody request with any body
	PatchObservabilityProjectWithBody(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchObservabilityProject(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, body PatchObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetObservabilityProjectCredentials request
	ResetObservabilityProjectCredentials(ctx context.Context, id ProjectID, params *ResetObservabilityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeObservabilityProject request
	ResumeObservabilityProject(ctx context.Context, id ProjectID, params *ResumeObservabilityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObservabilityProjectRoles request
	GetObservabilityProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObservabilityProjectStatus request
	GetObservabilityProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSecurityProjects request
	ListSecurityProjects(ctx context.Context, params *ListSecurityProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecurityProjectWithBody request with any body
	CreateSecurityProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecurityProject(ctx context.Context, body CreateSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecurityProject request
	DeleteSecurityProject(ctx context.Context, id ProjectID, params *DeleteSecurityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityProject request
	GetSecurityProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchSecurityProjectWithBody request with any body
	PatchSecurityProjectWithBody(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchSecurityProject(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, body PatchSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetSecurityProjectCredentials request
	ResetSecurityProjectCredentials(ctx context.Context, id ProjectID, params *ResetSecurityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResumeSecurityProject request
	ResumeSecurityProject(ctx context.Context, id ProjectID, params *ResumeSecurityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityProjectRoles request
	GetSecurityProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityProjectStatus request
	GetSecurityProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegion request
	GetRegion(ctx context.Context, id RegionID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListElasticsearchProjects(ctx context.Context, params *ListElasticsearchProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListElasticsearchProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateElasticsearchProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElasticsearchProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateElasticsearchProject(ctx context.Context, body CreateElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateElasticsearchProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteElasticsearchProject(ctx context.Context, id ProjectID, params *DeleteElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteElasticsearchProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElasticsearchProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElasticsearchProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchElasticsearchProjectWithBody(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchElasticsearchProjectRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchElasticsearchProject(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, body PatchElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchElasticsearchProjectRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetElasticsearchProjectCredentials(ctx context.Context, id ProjectID, params *ResetElasticsearchProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetElasticsearchProjectCredentialsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeElasticsearchProject(ctx context.Context, id ProjectID, params *ResumeElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeElasticsearchProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElasticsearchProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElasticsearchProjectRolesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetElasticsearchProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetElasticsearchProjectStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObservabilityProjects(ctx context.Context, params *ListObservabilityProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObservabilityProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateObservabilityProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateObservabilityProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateObservabilityProject(ctx context.Context, body CreateObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateObservabilityProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObservabilityProject(ctx context.Context, id ProjectID, params *DeleteObservabilityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObservabilityProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObservabilityProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObservabilityProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchObservabilityProjectWithBody(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchObservabilityProjectRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchObservabilityProject(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, body PatchObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchObservabilityProjectRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetObservabilityProjectCredentials(ctx context.Context, id ProjectID, params *ResetObservabilityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetObservabilityProjectCredentialsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeObservabilityProject(ctx context.Context, id ProjectID, params *ResumeObservabilityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeObservabilityProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObservabilityProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObservabilityProjectRolesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObservabilityProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObservabilityProjectStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSecurityProjects(ctx context.Context, params *ListSecurityProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSecurityProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecurityProject(ctx context.Context, body CreateSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecurityProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecurityProject(ctx context.Context, id ProjectID, params *DeleteSecurityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecurityProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityProject(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSecurityProjectWithBody(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSecurityProjectRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchSecurityProject(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, body PatchSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchSecurityProjectRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetSecurityProjectCredentials(ctx context.Context, id ProjectID, params *ResetSecurityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetSecurityProjectCredentialsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResumeSecurityProject(ctx context.Context, id ProjectID, params *ResumeSecurityProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResumeSecurityProjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityProjectRoles(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityProjectRolesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityProjectStatus(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityProjectStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegion(ctx context.Context, id RegionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListElasticsearchProjectsRequest generates requests for ListElasticsearchProjects
func NewListElasticsearchProjectsRequest(server string, params *ListElasticsearchProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateElasticsearchProjectRequest calls the generic CreateElasticsearchProject builder with application/json body
func NewCreateElasticsearchProjectRequest(server string, body CreateElasticsearchProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateElasticsearchProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateElasticsearchProjectRequestWithBody generates requests for CreateElasticsearchProject with any type of body
func NewCreateElasticsearchProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteElasticsearchProjectRequest generates requests for DeleteElasticsearchProject
func NewDeleteElasticsearchProjectRequest(server string, id ProjectID, params *DeleteElasticsearchProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetElasticsearchProjectRequest generates requests for GetElasticsearchProject
func NewGetElasticsearchProjectRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchElasticsearchProjectRequest calls the generic PatchElasticsearchProject builder with application/json body
func NewPatchElasticsearchProjectRequest(server string, id ProjectID, params *PatchElasticsearchProjectParams, body PatchElasticsearchProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchElasticsearchProjectRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchElasticsearchProjectRequestWithBody generates requests for PatchElasticsearchProject with any type of body
func NewPatchElasticsearchProjectRequestWithBody(server string, id ProjectID, params *PatchElasticsearchProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResetElasticsearchProjectCredentialsRequest generates requests for ResetElasticsearchProjectCredentials
func NewResetElasticsearchProjectCredentialsRequest(server string, id ProjectID, params *ResetElasticsearchProjectCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s/_reset-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResumeElasticsearchProjectRequest generates requests for ResumeElasticsearchProject
func NewResumeElasticsearchProjectRequest(server string, id ProjectID, params *ResumeElasticsearchProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s/_resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetElasticsearchProjectRolesRequest generates requests for GetElasticsearchProjectRoles
func NewGetElasticsearchProjectRolesRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetElasticsearchProjectStatusRequest generates requests for GetElasticsearchProjectStatus
func NewGetElasticsearchProjectStatusRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/elasticsearch/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListObservabilityProjectsRequest generates requests for ListObservabilityProjects
func NewListObservabilityProjectsRequest(server string, params *ListObservabilityProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateObservabilityProjectRequest calls the generic CreateObservabilityProject builder with application/json body
func NewCreateObservabilityProjectRequest(server string, body CreateObservabilityProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateObservabilityProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateObservabilityProjectRequestWithBody generates requests for CreateObservabilityProject with any type of body
func NewCreateObservabilityProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObservabilityProjectRequest generates requests for DeleteObservabilityProject
func NewDeleteObservabilityProjectRequest(server string, id ProjectID, params *DeleteObservabilityProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetObservabilityProjectRequest generates requests for GetObservabilityProject
func NewGetObservabilityProjectRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchObservabilityProjectRequest calls the generic PatchObservabilityProject builder with application/json body
func NewPatchObservabilityProjectRequest(server string, id ProjectID, params *PatchObservabilityProjectParams, body PatchObservabilityProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchObservabilityProjectRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchObservabilityProjectRequestWithBody generates requests for PatchObservabilityProject with any type of body
func NewPatchObservabilityProjectRequestWithBody(server string, id ProjectID, params *PatchObservabilityProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResetObservabilityProjectCredentialsRequest generates requests for ResetObservabilityProjectCredentials
func NewResetObservabilityProjectCredentialsRequest(server string, id ProjectID, params *ResetObservabilityProjectCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s/_reset-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResumeObservabilityProjectRequest generates requests for ResumeObservabilityProject
func NewResumeObservabilityProjectRequest(server string, id ProjectID, params *ResumeObservabilityProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s/_resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetObservabilityProjectRolesRequest generates requests for GetObservabilityProjectRoles
func NewGetObservabilityProjectRolesRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObservabilityProjectStatusRequest generates requests for GetObservabilityProjectStatus
func NewGetObservabilityProjectStatusRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/observability/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSecurityProjectsRequest generates requests for ListSecurityProjects
func NewListSecurityProjectsRequest(server string, params *ListSecurityProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecurityProjectRequest calls the generic CreateSecurityProject builder with application/json body
func NewCreateSecurityProjectRequest(server string, body CreateSecurityProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecurityProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSecurityProjectRequestWithBody generates requests for CreateSecurityProject with any type of body
func NewCreateSecurityProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecurityProjectRequest generates requests for DeleteSecurityProject
func NewDeleteSecurityProjectRequest(server string, id ProjectID, params *DeleteSecurityProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetSecurityProjectRequest generates requests for GetSecurityProject
func NewGetSecurityProjectRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchSecurityProjectRequest calls the generic PatchSecurityProject builder with application/json body
func NewPatchSecurityProjectRequest(server string, id ProjectID, params *PatchSecurityProjectParams, body PatchSecurityProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchSecurityProjectRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPatchSecurityProjectRequestWithBody generates requests for PatchSecurityProject with any type of body
func NewPatchSecurityProjectRequestWithBody(server string, id ProjectID, params *PatchSecurityProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResetSecurityProjectCredentialsRequest generates requests for ResetSecurityProjectCredentials
func NewResetSecurityProjectCredentialsRequest(server string, id ProjectID, params *ResetSecurityProjectCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s/_reset-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewResumeSecurityProjectRequest generates requests for ResumeSecurityProject
func NewResumeSecurityProjectRequest(server string, id ProjectID, params *ResumeSecurityProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s/_resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetSecurityProjectRolesRequest generates requests for GetSecurityProjectRoles
func NewGetSecurityProjectRolesRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityProjectStatusRequest generates requests for GetSecurityProjectStatus
func NewGetSecurityProjectStatusRequest(server string, id ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/projects/security/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/regions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegionRequest generates requests for GetRegion
func NewGetRegionRequest(server string, id RegionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverless/regions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListElasticsearchProjectsWithResponse request
	ListElasticsearchProjectsWithResponse(ctx context.Context, params *ListElasticsearchProjectsParams, reqEditors ...RequestEditorFn) (*ListElasticsearchProjectsResponse, error)

	// CreateElasticsearchProjectWithBodyWithResponse request with any body
	CreateElasticsearchProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElasticsearchProjectResponse, error)

	CreateElasticsearchProjectWithResponse(ctx context.Context, body CreateElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElasticsearchProjectResponse, error)

	// DeleteElasticsearchProjectWithResponse request
	DeleteElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*DeleteElasticsearchProjectResponse, error)

	// GetElasticsearchProjectWithResponse request
	GetElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectResponse, error)

	// PatchElasticsearchProjectWithBodyWithResponse request with any body
	PatchElasticsearchProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchElasticsearchProjectResponse, error)

	PatchElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, body PatchElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchElasticsearchProjectResponse, error)

	// ResetElasticsearchProjectCredentialsWithResponse request
	ResetElasticsearchProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetElasticsearchProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetElasticsearchProjectCredentialsResponse, error)

	// ResumeElasticsearchProjectWithResponse request
	ResumeElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*ResumeElasticsearchProjectResponse, error)

	// GetElasticsearchProjectRolesWithResponse request
	GetElasticsearchProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectRolesResponse, error)

	// GetElasticsearchProjectStatusWithResponse request
	GetElasticsearchProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectStatusResponse, error)

	// ListObservabilityProjectsWithResponse request
	ListObservabilityProjectsWithResponse(ctx context.Context, params *ListObservabilityProjectsParams, reqEditors ...RequestEditorFn) (*ListObservabilityProjectsResponse, error)

	// CreateObservabilityProjectWithBodyWithResponse request with any body
	CreateObservabilityProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateObservabilityProjectResponse, error)

	CreateObservabilityProjectWithResponse(ctx context.Context, body CreateObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateObservabilityProjectResponse, error)

	// DeleteObservabilityProjectWithResponse request
	DeleteObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteObservabilityProjectParams, reqEditors ...RequestEditorFn) (*DeleteObservabilityProjectResponse, error)

	// GetObservabilityProjectWithResponse request
	GetObservabilityProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectResponse, error)

	// PatchObservabilityProjectWithBodyWithResponse request with any body
	PatchObservabilityProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchObservabilityProjectResponse, error)

	PatchObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, body PatchObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchObservabilityProjectResponse, error)

	// ResetObservabilityProjectCredentialsWithResponse request
	ResetObservabilityProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetObservabilityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetObservabilityProjectCredentialsResponse, error)

	// ResumeObservabilityProjectWithResponse request
	ResumeObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeObservabilityProjectParams, reqEditors ...RequestEditorFn) (*ResumeObservabilityProjectResponse, error)

	// GetObservabilityProjectRolesWithResponse request
	GetObservabilityProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectRolesResponse, error)

	// GetObservabilityProjectStatusWithResponse request
	GetObservabilityProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectStatusResponse, error)

	// ListSecurityProjectsWithResponse request
	ListSecurityProjectsWithResponse(ctx context.Context, params *ListSecurityProjectsParams, reqEditors ...RequestEditorFn) (*ListSecurityProjectsResponse, error)

	// CreateSecurityProjectWithBodyWithResponse request with any body
	CreateSecurityProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityProjectResponse, error)

	CreateSecurityProjectWithResponse(ctx context.Context, body CreateSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityProjectResponse, error)

	// DeleteSecurityProjectWithResponse request
	DeleteSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteSecurityProjectParams, reqEditors ...RequestEditorFn) (*DeleteSecurityProjectResponse, error)

	// GetSecurityProjectWithResponse request
	GetSecurityProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectResponse, error)

	// PatchSecurityProjectWithBodyWithResponse request with any body
	PatchSecurityProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSecurityProjectResponse, error)

	PatchSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, body PatchSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSecurityProjectResponse, error)

	// ResetSecurityProjectCredentialsWithResponse request
	ResetSecurityProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetSecurityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetSecurityProjectCredentialsResponse, error)

	// ResumeSecurityProjectWithResponse request
	ResumeSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeSecurityProjectParams, reqEditors ...RequestEditorFn) (*ResumeSecurityProjectResponse, error)

	// GetSecurityProjectRolesWithResponse request
	GetSecurityProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectRolesResponse, error)

	// GetSecurityProjectStatusWithResponse request
	GetSecurityProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectStatusResponse, error)

	// ListRegionsWithResponse request
	ListRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error)

	// GetRegionWithResponse request
	GetRegionWithResponse(ctx context.Context, id RegionID, reqEditors ...RequestEditorFn) (*GetRegionResponse, error)
}

type ListElasticsearchProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticsearchProjectList
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListElasticsearchProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListElasticsearchProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateElasticsearchProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ElasticsearchProjectCreated
	JSON400      *BadRequest
	JSON422      *UnprocessableEntity
}

// Status returns HTTPResponse.Status
func (r CreateElasticsearchProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateElasticsearchProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteElasticsearchProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteElasticsearchProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteElasticsearchProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElasticsearchProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticsearchProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetElasticsearchProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElasticsearchProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchElasticsearchProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ElasticsearchProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchElasticsearchProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchElasticsearchProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetElasticsearchProjectCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentials
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResetElasticsearchProjectCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetElasticsearchProjectCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeElasticsearchProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResumeElasticsearchProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeElasticsearchProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElasticsearchProjectRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRolesByProjectID
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetElasticsearchProjectRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElasticsearchProjectRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetElasticsearchProjectStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectStatus
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetElasticsearchProjectStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetElasticsearchProjectStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObservabilityProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservabilityProjectList
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListObservabilityProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObservabilityProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateObservabilityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObservabilityProjectCreated
	JSON400      *BadRequest
	JSON422      *UnprocessableEntity
}

// Status returns HTTPResponse.Status
func (r CreateObservabilityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateObservabilityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObservabilityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteObservabilityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObservabilityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObservabilityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservabilityProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetObservabilityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObservabilityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchObservabilityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObservabilityProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchObservabilityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchObservabilityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetObservabilityProjectCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentials
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResetObservabilityProjectCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetObservabilityProjectCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeObservabilityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResumeObservabilityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeObservabilityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObservabilityProjectRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]ProjectRolesByProjectID
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetObservabilityProjectRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObservabilityProjectRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObservabilityProjectStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectStatus
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetObservabilityProjectStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObservabilityProjectStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSecurityProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityProjectList
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListSecurityProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSecurityProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecurityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SecurityProjectCreated
	JSON400      *BadRequest
	JSON422      *UnprocessableEntity
}

// Status returns HTTPResponse.Status
func (r CreateSecurityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecurityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecurityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteSecurityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecurityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSecurityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchSecurityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityProject
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r PatchSecurityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchSecurityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetSecurityProjectCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentials
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResetSecurityProjectCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetSecurityProjectCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResumeSecurityProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ResumeSecurityProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResumeSecurityProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityProjectRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]ProjectRolesByProjectID
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSecurityProjectRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityProjectRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityProjectStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectStatus
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetSecurityProjectStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityProjectStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Region
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Region
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListElasticsearchProjectsWithResponse request returning *ListElasticsearchProjectsResponse
func (c *ClientWithResponses) ListElasticsearchProjectsWithResponse(ctx context.Context, params *ListElasticsearchProjectsParams, reqEditors ...RequestEditorFn) (*ListElasticsearchProjectsResponse, error) {
	rsp, err := c.ListElasticsearchProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListElasticsearchProjectsResponse(rsp)
}

// CreateElasticsearchProjectWithBodyWithResponse request with arbitrary body returning *CreateElasticsearchProjectResponse
func (c *ClientWithResponses) CreateElasticsearchProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateElasticsearchProjectResponse, error) {
	rsp, err := c.CreateElasticsearchProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElasticsearchProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateElasticsearchProjectWithResponse(ctx context.Context, body CreateElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateElasticsearchProjectResponse, error) {
	rsp, err := c.CreateElasticsearchProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateElasticsearchProjectResponse(rsp)
}

// DeleteElasticsearchProjectWithResponse request returning *DeleteElasticsearchProjectResponse
func (c *ClientWithResponses) DeleteElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*DeleteElasticsearchProjectResponse, error) {
	rsp, err := c.DeleteElasticsearchProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteElasticsearchProjectResponse(rsp)
}

// GetElasticsearchProjectWithResponse request returning *GetElasticsearchProjectResponse
func (c *ClientWithResponses) GetElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectResponse, error) {
	rsp, err := c.GetElasticsearchProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElasticsearchProjectResponse(rsp)
}

// PatchElasticsearchProjectWithBodyWithResponse request with arbitrary body returning *PatchElasticsearchProjectResponse
func (c *ClientWithResponses) PatchElasticsearchProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchElasticsearchProjectResponse, error) {
	rsp, err := c.PatchElasticsearchProjectWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchElasticsearchProjectResponse(rsp)
}

func (c *ClientWithResponses) PatchElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *PatchElasticsearchProjectParams, body PatchElasticsearchProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchElasticsearchProjectResponse, error) {
	rsp, err := c.PatchElasticsearchProject(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchElasticsearchProjectResponse(rsp)
}

// ResetElasticsearchProjectCredentialsWithResponse request returning *ResetElasticsearchProjectCredentialsResponse
func (c *ClientWithResponses) ResetElasticsearchProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetElasticsearchProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetElasticsearchProjectCredentialsResponse, error) {
	rsp, err := c.ResetElasticsearchProjectCredentials(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetElasticsearchProjectCredentialsResponse(rsp)
}

// ResumeElasticsearchProjectWithResponse request returning *ResumeElasticsearchProjectResponse
func (c *ClientWithResponses) ResumeElasticsearchProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeElasticsearchProjectParams, reqEditors ...RequestEditorFn) (*ResumeElasticsearchProjectResponse, error) {
	rsp, err := c.ResumeElasticsearchProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeElasticsearchProjectResponse(rsp)
}

// GetElasticsearchProjectRolesWithResponse request returning *GetElasticsearchProjectRolesResponse
func (c *ClientWithResponses) GetElasticsearchProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectRolesResponse, error) {
	rsp, err := c.GetElasticsearchProjectRoles(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElasticsearchProjectRolesResponse(rsp)
}

// GetElasticsearchProjectStatusWithResponse request returning *GetElasticsearchProjectStatusResponse
func (c *ClientWithResponses) GetElasticsearchProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetElasticsearchProjectStatusResponse, error) {
	rsp, err := c.GetElasticsearchProjectStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetElasticsearchProjectStatusResponse(rsp)
}

// ListObservabilityProjectsWithResponse request returning *ListObservabilityProjectsResponse
func (c *ClientWithResponses) ListObservabilityProjectsWithResponse(ctx context.Context, params *ListObservabilityProjectsParams, reqEditors ...RequestEditorFn) (*ListObservabilityProjectsResponse, error) {
	rsp, err := c.ListObservabilityProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObservabilityProjectsResponse(rsp)
}

// CreateObservabilityProjectWithBodyWithResponse request with arbitrary body returning *CreateObservabilityProjectResponse
func (c *ClientWithResponses) CreateObservabilityProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateObservabilityProjectResponse, error) {
	rsp, err := c.CreateObservabilityProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateObservabilityProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateObservabilityProjectWithResponse(ctx context.Context, body CreateObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateObservabilityProjectResponse, error) {
	rsp, err := c.CreateObservabilityProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateObservabilityProjectResponse(rsp)
}

// DeleteObservabilityProjectWithResponse request returning *DeleteObservabilityProjectResponse
func (c *ClientWithResponses) DeleteObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteObservabilityProjectParams, reqEditors ...RequestEditorFn) (*DeleteObservabilityProjectResponse, error) {
	rsp, err := c.DeleteObservabilityProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObservabilityProjectResponse(rsp)
}

// GetObservabilityProjectWithResponse request returning *GetObservabilityProjectResponse
func (c *ClientWithResponses) GetObservabilityProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectResponse, error) {
	rsp, err := c.GetObservabilityProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObservabilityProjectResponse(rsp)
}

// PatchObservabilityProjectWithBodyWithResponse request with arbitrary body returning *PatchObservabilityProjectResponse
func (c *ClientWithResponses) PatchObservabilityProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchObservabilityProjectResponse, error) {
	rsp, err := c.PatchObservabilityProjectWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchObservabilityProjectResponse(rsp)
}

func (c *ClientWithResponses) PatchObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *PatchObservabilityProjectParams, body PatchObservabilityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchObservabilityProjectResponse, error) {
	rsp, err := c.PatchObservabilityProject(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchObservabilityProjectResponse(rsp)
}

// ResetObservabilityProjectCredentialsWithResponse request returning *ResetObservabilityProjectCredentialsResponse
func (c *ClientWithResponses) ResetObservabilityProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetObservabilityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetObservabilityProjectCredentialsResponse, error) {
	rsp, err := c.ResetObservabilityProjectCredentials(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetObservabilityProjectCredentialsResponse(rsp)
}

// ResumeObservabilityProjectWithResponse request returning *ResumeObservabilityProjectResponse
func (c *ClientWithResponses) ResumeObservabilityProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeObservabilityProjectParams, reqEditors ...RequestEditorFn) (*ResumeObservabilityProjectResponse, error) {
	rsp, err := c.ResumeObservabilityProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeObservabilityProjectResponse(rsp)
}

// GetObservabilityProjectRolesWithResponse request returning *GetObservabilityProjectRolesResponse
func (c *ClientWithResponses) GetObservabilityProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectRolesResponse, error) {
	rsp, err := c.GetObservabilityProjectRoles(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObservabilityProjectRolesResponse(rsp)
}

// GetObservabilityProjectStatusWithResponse request returning *GetObservabilityProjectStatusResponse
func (c *ClientWithResponses) GetObservabilityProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetObservabilityProjectStatusResponse, error) {
	rsp, err := c.GetObservabilityProjectStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObservabilityProjectStatusResponse(rsp)
}

// ListSecurityProjectsWithResponse request returning *ListSecurityProjectsResponse
func (c *ClientWithResponses) ListSecurityProjectsWithResponse(ctx context.Context, params *ListSecurityProjectsParams, reqEditors ...RequestEditorFn) (*ListSecurityProjectsResponse, error) {
	rsp, err := c.ListSecurityProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSecurityProjectsResponse(rsp)
}

// CreateSecurityProjectWithBodyWithResponse request with arbitrary body returning *CreateSecurityProjectResponse
func (c *ClientWithResponses) CreateSecurityProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecurityProjectResponse, error) {
	rsp, err := c.CreateSecurityProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateSecurityProjectWithResponse(ctx context.Context, body CreateSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecurityProjectResponse, error) {
	rsp, err := c.CreateSecurityProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecurityProjectResponse(rsp)
}

// DeleteSecurityProjectWithResponse request returning *DeleteSecurityProjectResponse
func (c *ClientWithResponses) DeleteSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *DeleteSecurityProjectParams, reqEditors ...RequestEditorFn) (*DeleteSecurityProjectResponse, error) {
	rsp, err := c.DeleteSecurityProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecurityProjectResponse(rsp)
}

// GetSecurityProjectWithResponse request returning *GetSecurityProjectResponse
func (c *ClientWithResponses) GetSecurityProjectWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectResponse, error) {
	rsp, err := c.GetSecurityProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityProjectResponse(rsp)
}

// PatchSecurityProjectWithBodyWithResponse request with arbitrary body returning *PatchSecurityProjectResponse
func (c *ClientWithResponses) PatchSecurityProjectWithBodyWithResponse(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchSecurityProjectResponse, error) {
	rsp, err := c.PatchSecurityProjectWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSecurityProjectResponse(rsp)
}

func (c *ClientWithResponses) PatchSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *PatchSecurityProjectParams, body PatchSecurityProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchSecurityProjectResponse, error) {
	rsp, err := c.PatchSecurityProject(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchSecurityProjectResponse(rsp)
}

// ResetSecurityProjectCredentialsWithResponse request returning *ResetSecurityProjectCredentialsResponse
func (c *ClientWithResponses) ResetSecurityProjectCredentialsWithResponse(ctx context.Context, id ProjectID, params *ResetSecurityProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ResetSecurityProjectCredentialsResponse, error) {
	rsp, err := c.ResetSecurityProjectCredentials(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetSecurityProjectCredentialsResponse(rsp)
}

// ResumeSecurityProjectWithResponse request returning *ResumeSecurityProjectResponse
func (c *ClientWithResponses) ResumeSecurityProjectWithResponse(ctx context.Context, id ProjectID, params *ResumeSecurityProjectParams, reqEditors ...RequestEditorFn) (*ResumeSecurityProjectResponse, error) {
	rsp, err := c.ResumeSecurityProject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResumeSecurityProjectResponse(rsp)
}

// GetSecurityProjectRolesWithResponse request returning *GetSecurityProjectRolesResponse
func (c *ClientWithResponses) GetSecurityProjectRolesWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectRolesResponse, error) {
	rsp, err := c.GetSecurityProjectRoles(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityProjectRolesResponse(rsp)
}

// GetSecurityProjectStatusWithResponse request returning *GetSecurityProjectStatusResponse
func (c *ClientWithResponses) GetSecurityProjectStatusWithResponse(ctx context.Context, id ProjectID, reqEditors ...RequestEditorFn) (*GetSecurityProjectStatusResponse, error) {
	rsp, err := c.GetSecurityProjectStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityProjectStatusResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// GetRegionWithResponse request returning *GetRegionResponse
func (c *ClientWithResponses) GetRegionWithResponse(ctx context.Context, id RegionID, reqEditors ...RequestEditorFn) (*GetRegionResponse, error) {
	rsp, err := c.GetRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegionResponse(rsp)
}

// ParseListElasticsearchProjectsResponse parses an HTTP response from a ListElasticsearchProjectsWithResponse call
func ParseListElasticsearchProjectsResponse(rsp *http.Response) (*ListElasticsearchProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListElasticsearchProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticsearchProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateElasticsearchProjectResponse parses an HTTP response from a CreateElasticsearchProjectWithResponse call
func ParseCreateElasticsearchProjectResponse(rsp *http.Response) (*CreateElasticsearchProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateElasticsearchProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ElasticsearchProjectCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteElasticsearchProjectResponse parses an HTTP response from a DeleteElasticsearchProjectWithResponse call
func ParseDeleteElasticsearchProjectResponse(rsp *http.Response) (*DeleteElasticsearchProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteElasticsearchProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetElasticsearchProjectResponse parses an HTTP response from a GetElasticsearchProjectWithResponse call
func ParseGetElasticsearchProjectResponse(rsp *http.Response) (*GetElasticsearchProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElasticsearchProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticsearchProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchElasticsearchProjectResponse parses an HTTP response from a PatchElasticsearchProjectWithResponse call
func ParsePatchElasticsearchProjectResponse(rsp *http.Response) (*PatchElasticsearchProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchElasticsearchProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ElasticsearchProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResetElasticsearchProjectCredentialsResponse parses an HTTP response from a ResetElasticsearchProjectCredentialsWithResponse call
func ParseResetElasticsearchProjectCredentialsResponse(rsp *http.Response) (*ResetElasticsearchProjectCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetElasticsearchProjectCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResumeElasticsearchProjectResponse parses an HTTP response from a ResumeElasticsearchProjectWithResponse call
func ParseResumeElasticsearchProjectResponse(rsp *http.Response) (*ResumeElasticsearchProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeElasticsearchProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetElasticsearchProjectRolesResponse parses an HTTP response from a GetElasticsearchProjectRolesWithResponse call
func ParseGetElasticsearchProjectRolesResponse(rsp *http.Response) (*GetElasticsearchProjectRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElasticsearchProjectRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRolesByProjectID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetElasticsearchProjectStatusResponse parses an HTTP response from a GetElasticsearchProjectStatusWithResponse call
func ParseGetElasticsearchProjectStatusResponse(rsp *http.Response) (*GetElasticsearchProjectStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetElasticsearchProjectStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListObservabilityProjectsResponse parses an HTTP response from a ListObservabilityProjectsWithResponse call
func ParseListObservabilityProjectsResponse(rsp *http.Response) (*ListObservabilityProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListObservabilityProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservabilityProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateObservabilityProjectResponse parses an HTTP response from a CreateObservabilityProjectWithResponse call
func ParseCreateObservabilityProjectResponse(rsp *http.Response) (*CreateObservabilityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateObservabilityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObservabilityProjectCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteObservabilityProjectResponse parses an HTTP response from a DeleteObservabilityProjectWithResponse call
func ParseDeleteObservabilityProjectResponse(rsp *http.Response) (*DeleteObservabilityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObservabilityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetObservabilityProjectResponse parses an HTTP response from a GetObservabilityProjectWithResponse call
func ParseGetObservabilityProjectResponse(rsp *http.Response) (*GetObservabilityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObservabilityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservabilityProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchObservabilityProjectResponse parses an HTTP response from a PatchObservabilityProjectWithResponse call
func ParsePatchObservabilityProjectResponse(rsp *http.Response) (*PatchObservabilityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchObservabilityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObservabilityProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResetObservabilityProjectCredentialsResponse parses an HTTP response from a ResetObservabilityProjectCredentialsWithResponse call
func ParseResetObservabilityProjectCredentialsResponse(rsp *http.Response) (*ResetObservabilityProjectCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetObservabilityProjectCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResumeObservabilityProjectResponse parses an HTTP response from a ResumeObservabilityProjectWithResponse call
func ParseResumeObservabilityProjectResponse(rsp *http.Response) (*ResumeObservabilityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeObservabilityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetObservabilityProjectRolesResponse parses an HTTP response from a GetObservabilityProjectRolesWithResponse call
func ParseGetObservabilityProjectRolesResponse(rsp *http.Response) (*GetObservabilityProjectRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObservabilityProjectRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]ProjectRolesByProjectID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetObservabilityProjectStatusResponse parses an HTTP response from a GetObservabilityProjectStatusWithResponse call
func ParseGetObservabilityProjectStatusResponse(rsp *http.Response) (*GetObservabilityProjectStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObservabilityProjectStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListSecurityProjectsResponse parses an HTTP response from a ListSecurityProjectsWithResponse call
func ParseListSecurityProjectsResponse(rsp *http.Response) (*ListSecurityProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSecurityProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityProjectList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateSecurityProjectResponse parses an HTTP response from a CreateSecurityProjectWithResponse call
func ParseCreateSecurityProjectResponse(rsp *http.Response) (*CreateSecurityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecurityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SecurityProjectCreated
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteSecurityProjectResponse parses an HTTP response from a DeleteSecurityProjectWithResponse call
func ParseDeleteSecurityProjectResponse(rsp *http.Response) (*DeleteSecurityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecurityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSecurityProjectResponse parses an HTTP response from a GetSecurityProjectWithResponse call
func ParseGetSecurityProjectResponse(rsp *http.Response) (*GetSecurityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchSecurityProjectResponse parses an HTTP response from a PatchSecurityProjectWithResponse call
func ParsePatchSecurityProjectResponse(rsp *http.Response) (*PatchSecurityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchSecurityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResetSecurityProjectCredentialsResponse parses an HTTP response from a ResetSecurityProjectCredentialsWithResponse call
func ParseResetSecurityProjectCredentialsResponse(rsp *http.Response) (*ResetSecurityProjectCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetSecurityProjectCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResumeSecurityProjectResponse parses an HTTP response from a ResumeSecurityProjectWithResponse call
func ParseResumeSecurityProjectResponse(rsp *http.Response) (*ResumeSecurityProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResumeSecurityProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSecurityProjectRolesResponse parses an HTTP response from a GetSecurityProjectRolesWithResponse call
func ParseGetSecurityProjectRolesResponse(rsp *http.Response) (*GetSecurityProjectRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityProjectRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]ProjectRolesByProjectID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSecurityProjectStatusResponse parses an HTTP response from a GetSecurityProjectStatusWithResponse call
func ParseGetSecurityProjectStatusResponse(rsp *http.Response) (*GetSecurityProjectStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityProjectStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Region
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetRegionResponse parses an HTTP response from a GetRegionWithResponse call
func ParseGetRegionResponse(rsp *http.Response) (*GetRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Region
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
