// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_elasticsearch_project

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ElasticsearchProjectResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"alias": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.",
				MarkdownDescription: "A custom domain label compatible with RFC-1035 standards. Derived from the project name by default.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 50),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z]{1}(?:[a-zA-Z0-9-]*[a-zA-Z0-9]{1})?$"), ""),
				},
			},
			"cloud_id": schema.StringAttribute{
				Computed:            true,
				Description:         "The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.",
				MarkdownDescription: "The cloud ID, an encoded string that provides other Elastic services with the necessary information to connect to this Elasticsearch and Kibana.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"credentials": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"password": schema.StringAttribute{
						Computed:            true,
						Description:         "Basic auth password that can be used to access the Elasticsearch API.",
						MarkdownDescription: "Basic auth password that can be used to access the Elasticsearch API.",
					},
					"username": schema.StringAttribute{
						Computed:            true,
						Description:         "Basic auth username that can be used to access the Elasticsearch API.",
						MarkdownDescription: "Basic auth username that can be used to access the Elasticsearch API.",
					},
				},
				CustomType: CredentialsType{
					ObjectType: types.ObjectType{
						AttrTypes: CredentialsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Basic auth credentials to access the Elasticsearch API.",
				MarkdownDescription: "Basic auth credentials to access the Elasticsearch API.",
			},
			"endpoints": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"elasticsearch": schema.StringAttribute{
						Computed:            true,
						Description:         "The endpoint to access elasticsearch.",
						MarkdownDescription: "The endpoint to access elasticsearch.",
					},
					"kibana": schema.StringAttribute{
						Computed:            true,
						Description:         "The endpoint to access kibana.",
						MarkdownDescription: "The endpoint to access kibana.",
					},
				},
				CustomType: EndpointsType{
					ObjectType: types.ObjectType{
						AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The endpoints to access the different apps of the project.",
				MarkdownDescription: "The endpoints to access the different apps of the project.",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "ID of the project.",
				MarkdownDescription: "ID of the project.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "Date and time when the project was created.",
						MarkdownDescription: "Date and time when the project was created.",
					},
					"created_by": schema.StringAttribute{
						Computed:            true,
						Description:         "ID of the user.",
						MarkdownDescription: "ID of the user.",
					},
					"organization_id": schema.StringAttribute{
						Computed:            true,
						Description:         "The Organization ID who owns the project.",
						MarkdownDescription: "The Organization ID who owns the project.",
					},
					"suspended_at": schema.StringAttribute{
						Computed:            true,
						Description:         "Date and time when the project was suspended.",
						MarkdownDescription: "Date and time when the project was suspended.",
					},
					"suspended_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Reason why the project was suspended.",
						MarkdownDescription: "Reason why the project was suspended.",
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Additional details about the project.",
				MarkdownDescription: "Additional details about the project.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Descriptive name for a project.",
				MarkdownDescription: "Descriptive name for a project.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 255),
				},
			},
			"optimized_for": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.",
				MarkdownDescription: "The purpose for which the hardware of this elasticsearch project is optimized for. Also known as the Elasticsearch project subtype.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(
						"general_purpose",
						"vector",
					),
				},
			},
			"region_id": schema.StringAttribute{
				Required:            true,
				Description:         "Unique human-readable identifier for a region in Elastic Cloud.",
				MarkdownDescription: "Unique human-readable identifier for a region in Elastic Cloud.",
			},
			"search_lake": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"boost_window": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Determines how much data can benefit from faster search. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. The system dynamically adjusts the cache allocated to your project based on how much data you ingest during the period defined by your Search Boost Window.",
						MarkdownDescription: "Determines how much data can benefit from faster search. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. The system dynamically adjusts the cache allocated to your project based on how much data you ingest during the period defined by your Search Boost Window.",
						Validators: []validator.Int64{
							int64validator.Between(0, 180),
						},
					},
					"search_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Controls how fast searches are against your project data. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. You can either increase the performance of searches on cached data by adding replicas, or reduce the quantity of cached data by a static factor to save on costs.",
						MarkdownDescription: "Controls how fast searches are against your project data. When ingested, a certain amount of data is loaded into a cache that makes it super fast to query. You can either increase the performance of searches on cached data by adding replicas, or reduce the quantity of cached data by a static factor to save on costs.",
						Validators: []validator.Int64{
							int64validator.Between(5, 3000),
						},
					},
				},
				CustomType: SearchLakeType{
					ObjectType: types.ObjectType{
						AttrTypes: SearchLakeValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Configuration for entire set of capabilities that make the data searchable in Elasticsearch.",
				MarkdownDescription: "Configuration for entire set of capabilities that make the data searchable in Elasticsearch.",
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "the type of the project",
				MarkdownDescription: "the type of the project",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

type ElasticsearchProjectModel struct {
	Alias        types.String     `tfsdk:"alias"`
	CloudId      types.String     `tfsdk:"cloud_id"`
	Credentials  CredentialsValue `tfsdk:"credentials"`
	Endpoints    EndpointsValue   `tfsdk:"endpoints"`
	Id           types.String     `tfsdk:"id"`
	Metadata     MetadataValue    `tfsdk:"metadata"`
	Name         types.String     `tfsdk:"name"`
	OptimizedFor types.String     `tfsdk:"optimized_for"`
	RegionId     types.String     `tfsdk:"region_id"`
	SearchLake   SearchLakeValue  `tfsdk:"search_lake"`
	Type         types.String     `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = CredentialsType{}

type CredentialsType struct {
	basetypes.ObjectType
}

func (t CredentialsType) Equal(o attr.Type) bool {
	other, ok := o.(CredentialsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CredentialsType) String() string {
	return "CredentialsType"
}

func (t CredentialsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CredentialsValue{
		Password: passwordVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCredentialsValueNull() CredentialsValue {
	return CredentialsValue{
		state: attr.ValueStateNull,
	}
}

func NewCredentialsValueUnknown() CredentialsValue {
	return CredentialsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCredentialsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CredentialsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CredentialsValue Attribute Value",
				"While creating a CredentialsValue value, a missing attribute value was detected. "+
					"A CredentialsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CredentialsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CredentialsValue Attribute Type",
				"While creating a CredentialsValue value, an invalid attribute value was detected. "+
					"A CredentialsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CredentialsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CredentialsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CredentialsValue Attribute Value",
				"While creating a CredentialsValue value, an extra attribute value was detected. "+
					"A CredentialsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CredentialsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCredentialsValueUnknown(), diags
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewCredentialsValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewCredentialsValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewCredentialsValueUnknown(), diags
	}

	return CredentialsValue{
		Password: passwordVal,
		Username: usernameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCredentialsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CredentialsValue {
	object, diags := NewCredentialsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCredentialsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CredentialsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCredentialsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCredentialsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCredentialsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCredentialsValueMust(CredentialsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CredentialsType) ValueType(ctx context.Context) attr.Value {
	return CredentialsValue{}
}

var _ basetypes.ObjectValuable = CredentialsValue{}

type CredentialsValue struct {
	Password basetypes.StringValue `tfsdk:"password"`
	Username basetypes.StringValue `tfsdk:"username"`
	state    attr.ValueState
}

func (v CredentialsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CredentialsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CredentialsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CredentialsValue) String() string {
	return "CredentialsValue"
}

func (v CredentialsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"password": basetypes.StringType{},
		"username": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"password": v.Password,
			"username": v.Username,
		})

	return objVal, diags
}

func (v CredentialsValue) Equal(o attr.Value) bool {
	other, ok := o.(CredentialsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v CredentialsValue) Type(ctx context.Context) attr.Type {
	return CredentialsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CredentialsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"password": basetypes.StringType{},
		"username": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointsType{}

type EndpointsType struct {
	basetypes.ObjectType
}

func (t EndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointsType) String() string {
	return "EndpointsType"
}

func (t EndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	elasticsearchAttribute, ok := attributes["elasticsearch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`elasticsearch is missing from object`)

		return nil, diags
	}

	elasticsearchVal, ok := elasticsearchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`elasticsearch expected to be basetypes.StringValue, was: %T`, elasticsearchAttribute))
	}

	kibanaAttribute, ok := attributes["kibana"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kibana is missing from object`)

		return nil, diags
	}

	kibanaVal, ok := kibanaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kibana expected to be basetypes.StringValue, was: %T`, kibanaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointsValue{
		Elasticsearch: elasticsearchVal,
		Kibana:        kibanaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueNull() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointsValueUnknown() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, a missing attribute value was detected. "+
					"A EndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointsValue Attribute Type",
				"While creating a EndpointsValue value, an invalid attribute value was detected. "+
					"A EndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, an extra attribute value was detected. "+
					"A EndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	elasticsearchAttribute, ok := attributes["elasticsearch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`elasticsearch is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	elasticsearchVal, ok := elasticsearchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`elasticsearch expected to be basetypes.StringValue, was: %T`, elasticsearchAttribute))
	}

	kibanaAttribute, ok := attributes["kibana"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kibana is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	kibanaVal, ok := kibanaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kibana expected to be basetypes.StringValue, was: %T`, kibanaAttribute))
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	return EndpointsValue{
		Elasticsearch: elasticsearchVal,
		Kibana:        kibanaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointsValue {
	object, diags := NewEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointsValueMust(EndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointsType) ValueType(ctx context.Context) attr.Value {
	return EndpointsValue{}
}

var _ basetypes.ObjectValuable = EndpointsValue{}

type EndpointsValue struct {
	Elasticsearch basetypes.StringValue `tfsdk:"elasticsearch"`
	Kibana        basetypes.StringValue `tfsdk:"kibana"`
	state         attr.ValueState
}

func (v EndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["elasticsearch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kibana"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Elasticsearch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["elasticsearch"] = val

		val, err = v.Kibana.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kibana"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointsValue) String() string {
	return "EndpointsValue"
}

func (v EndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"elasticsearch": basetypes.StringType{},
		"kibana":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"elasticsearch": v.Elasticsearch,
			"kibana":        v.Kibana,
		})

	return objVal, diags
}

func (v EndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Elasticsearch.Equal(other.Elasticsearch) {
		return false
	}

	if !v.Kibana.Equal(other.Kibana) {
		return false
	}

	return true
}

func (v EndpointsValue) Type(ctx context.Context) attr.Type {
	return EndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"elasticsearch": basetypes.StringType{},
		"kibana":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return nil, diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	organizationIdAttribute, ok := attributes["organization_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_id is missing from object`)

		return nil, diags
	}

	organizationIdVal, ok := organizationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_id expected to be basetypes.StringValue, was: %T`, organizationIdAttribute))
	}

	suspendedAtAttribute, ok := attributes["suspended_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspended_at is missing from object`)

		return nil, diags
	}

	suspendedAtVal, ok := suspendedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspended_at expected to be basetypes.StringValue, was: %T`, suspendedAtAttribute))
	}

	suspendedReasonAttribute, ok := attributes["suspended_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspended_reason is missing from object`)

		return nil, diags
	}

	suspendedReasonVal, ok := suspendedReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspended_reason expected to be basetypes.StringValue, was: %T`, suspendedReasonAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		CreatedAt:       createdAtVal,
		CreatedBy:       createdByVal,
		OrganizationId:  organizationIdVal,
		SuspendedAt:     suspendedAtVal,
		SuspendedReason: suspendedReasonVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	createdByAttribute, ok := attributes["created_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_by is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	createdByVal, ok := createdByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_by expected to be basetypes.StringValue, was: %T`, createdByAttribute))
	}

	organizationIdAttribute, ok := attributes["organization_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_id is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	organizationIdVal, ok := organizationIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_id expected to be basetypes.StringValue, was: %T`, organizationIdAttribute))
	}

	suspendedAtAttribute, ok := attributes["suspended_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspended_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	suspendedAtVal, ok := suspendedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspended_at expected to be basetypes.StringValue, was: %T`, suspendedAtAttribute))
	}

	suspendedReasonAttribute, ok := attributes["suspended_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`suspended_reason is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	suspendedReasonVal, ok := suspendedReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`suspended_reason expected to be basetypes.StringValue, was: %T`, suspendedReasonAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		CreatedAt:       createdAtVal,
		CreatedBy:       createdByVal,
		OrganizationId:  organizationIdVal,
		SuspendedAt:     suspendedAtVal,
		SuspendedReason: suspendedReasonVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	CreatedAt       basetypes.StringValue `tfsdk:"created_at"`
	CreatedBy       basetypes.StringValue `tfsdk:"created_by"`
	OrganizationId  basetypes.StringValue `tfsdk:"organization_id"`
	SuspendedAt     basetypes.StringValue `tfsdk:"suspended_at"`
	SuspendedReason basetypes.StringValue `tfsdk:"suspended_reason"`
	state           attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["suspended_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["suspended_reason"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CreatedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_by"] = val

		val, err = v.OrganizationId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_id"] = val

		val, err = v.SuspendedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["suspended_at"] = val

		val, err = v.SuspendedReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["suspended_reason"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":       basetypes.StringType{},
		"created_by":       basetypes.StringType{},
		"organization_id":  basetypes.StringType{},
		"suspended_at":     basetypes.StringType{},
		"suspended_reason": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":       v.CreatedAt,
			"created_by":       v.CreatedBy,
			"organization_id":  v.OrganizationId,
			"suspended_at":     v.SuspendedAt,
			"suspended_reason": v.SuspendedReason,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CreatedBy.Equal(other.CreatedBy) {
		return false
	}

	if !v.OrganizationId.Equal(other.OrganizationId) {
		return false
	}

	if !v.SuspendedAt.Equal(other.SuspendedAt) {
		return false
	}

	if !v.SuspendedReason.Equal(other.SuspendedReason) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":       basetypes.StringType{},
		"created_by":       basetypes.StringType{},
		"organization_id":  basetypes.StringType{},
		"suspended_at":     basetypes.StringType{},
		"suspended_reason": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SearchLakeType{}

type SearchLakeType struct {
	basetypes.ObjectType
}

func (t SearchLakeType) Equal(o attr.Type) bool {
	other, ok := o.(SearchLakeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SearchLakeType) String() string {
	return "SearchLakeType"
}

func (t SearchLakeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	boostWindowAttribute, ok := attributes["boost_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boost_window is missing from object`)

		return nil, diags
	}

	boostWindowVal, ok := boostWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boost_window expected to be basetypes.Int64Value, was: %T`, boostWindowAttribute))
	}

	searchPowerAttribute, ok := attributes["search_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`search_power is missing from object`)

		return nil, diags
	}

	searchPowerVal, ok := searchPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`search_power expected to be basetypes.Int64Value, was: %T`, searchPowerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SearchLakeValue{
		BoostWindow: boostWindowVal,
		SearchPower: searchPowerVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSearchLakeValueNull() SearchLakeValue {
	return SearchLakeValue{
		state: attr.ValueStateNull,
	}
}

func NewSearchLakeValueUnknown() SearchLakeValue {
	return SearchLakeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSearchLakeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SearchLakeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SearchLakeValue Attribute Value",
				"While creating a SearchLakeValue value, a missing attribute value was detected. "+
					"A SearchLakeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SearchLakeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SearchLakeValue Attribute Type",
				"While creating a SearchLakeValue value, an invalid attribute value was detected. "+
					"A SearchLakeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SearchLakeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SearchLakeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SearchLakeValue Attribute Value",
				"While creating a SearchLakeValue value, an extra attribute value was detected. "+
					"A SearchLakeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SearchLakeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSearchLakeValueUnknown(), diags
	}

	boostWindowAttribute, ok := attributes["boost_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boost_window is missing from object`)

		return NewSearchLakeValueUnknown(), diags
	}

	boostWindowVal, ok := boostWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boost_window expected to be basetypes.Int64Value, was: %T`, boostWindowAttribute))
	}

	searchPowerAttribute, ok := attributes["search_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`search_power is missing from object`)

		return NewSearchLakeValueUnknown(), diags
	}

	searchPowerVal, ok := searchPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`search_power expected to be basetypes.Int64Value, was: %T`, searchPowerAttribute))
	}

	if diags.HasError() {
		return NewSearchLakeValueUnknown(), diags
	}

	return SearchLakeValue{
		BoostWindow: boostWindowVal,
		SearchPower: searchPowerVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSearchLakeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SearchLakeValue {
	object, diags := NewSearchLakeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSearchLakeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SearchLakeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSearchLakeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSearchLakeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSearchLakeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSearchLakeValueMust(SearchLakeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SearchLakeType) ValueType(ctx context.Context) attr.Value {
	return SearchLakeValue{}
}

var _ basetypes.ObjectValuable = SearchLakeValue{}

type SearchLakeValue struct {
	BoostWindow basetypes.Int64Value `tfsdk:"boost_window"`
	SearchPower basetypes.Int64Value `tfsdk:"search_power"`
	state       attr.ValueState
}

func (v SearchLakeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["boost_window"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["search_power"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.BoostWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["boost_window"] = val

		val, err = v.SearchPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["search_power"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SearchLakeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SearchLakeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SearchLakeValue) String() string {
	return "SearchLakeValue"
}

func (v SearchLakeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"boost_window": basetypes.Int64Type{},
		"search_power": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"boost_window": v.BoostWindow,
			"search_power": v.SearchPower,
		})

	return objVal, diags
}

func (v SearchLakeValue) Equal(o attr.Value) bool {
	other, ok := o.(SearchLakeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BoostWindow.Equal(other.BoostWindow) {
		return false
	}

	if !v.SearchPower.Equal(other.SearchPower) {
		return false
	}

	return true
}

func (v SearchLakeValue) Type(ctx context.Context) attr.Type {
	return SearchLakeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SearchLakeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"boost_window": basetypes.Int64Type{},
		"search_power": basetypes.Int64Type{},
	}
}
